# 数据库的锁机制——RAW

> 数据库在并发访问到情况下，可能会出现脏读/不可重复读/幻读等读现象，为了应对这些问题，一般数据库都提供了锁机制，并引入了事务隔离级别的概念。而并发控制，就是利用了这些锁机制，来确保在多个事务同时存取数据库中同一数据时不破坏事务到隔离性和统一性以及数据库到统一性。



## 锁：是在执行多线程时用于强行限制资源访问到同步机制，来满足并发控制中保证对互斥要求到满足。



### 锁的分类

1. **按操作划分：**
   - DML锁
   - DDL锁
2. **按锁的粒度划分：**
   - 表级锁
   - 行级锁
   - 页级锁（mysql)
3. **按锁的级别划分：**
   - 共享锁
   - 排他锁
4. **按加锁的方式划分：**
   - 自动锁
   - 显式锁
5. **按使用方式划分**
   - 乐观锁
   - 悲观锁






#### 按操作划分：

- DML锁:(data locks数据锁)，DML代表数据操纵语言，如INSERT，UPDATE，MERGE，DELETE等，它用于保护数据的完整性，确保一次只有一个用户可以修改，其中包括`行级锁TX(Row Locks)`，`表级锁TM(Table Locks)`。
- DDL锁:(dictionary locks数据字典锁)，用于保护数据库对象的结构，如表，索引等结构的定义。
  - 排他DLL锁(Exclusive DDL lock):这会防止其他会话得到他们自己的DDL锁或TM锁。这说明，在DDL操作期间可以查询一个表，但是无法以任何方式修改这个表。
  - 共享DDL锁(Share DDL lock):这些锁会保护所引用的对象的结构，使之不会被其他会话修改，但是允许修改数据。
  - 可中断解析锁(Breakable parse lock):这些锁允许一个对象向其他对象注册其依赖性。






#### 按锁的粒度划分：

- 表级锁(INNODB引擎)：表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为**表共享读锁（共享锁）**与**表独占写锁（排他锁）**。
- 行级锁(MYISAM引擎)：行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为**共享锁** 和 **排他锁**。
- 页级锁(mysql)(BDB引擎)：页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁

**开销、加锁速度、死锁、粒度、并发性能**

- 表锁：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低
- 行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高
- 页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般


MySQL常用存储引擎的锁机制

    MyISAM和MEMORY采用表级锁(table-level locking)
    
    BDB采用页面锁(page-level locking)或表级锁，默认为页面锁
    
    InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

Innodb中的行锁与表锁

前面提到过，在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？

InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！

在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。

    在不通过索引条件查询的时候,InnoDB 确实使用的是表锁,而不是行锁。
    由于 MySQL 的行锁是针对索引加的锁,不是针对记录加的锁,所以虽然是访问不同行 的记录,但是如果是使用相同的索引键,是会出现锁冲突的。应用设计的时候要注意这一点。
    当表有多个索引的时候,不同的事务可以使用不同的索引锁定不同的行,另外,不论 是使用主键索引、唯一索引或普通索引,InnoDB 都会使用行锁来对数据加锁。
    即便在条件中使用了索引字段,但是否使用索引来检索数据是由 MySQL 通过判断不同 执行计划的代价来决定的,如果 MySQL 认为全表扫 效率更高,比如对一些很小的表,它 就不会使用索引,这种情况下 InnoDB 将使用表锁,而不是行锁。因此,在分析锁冲突时, 别忘了检查 SQL 的执行计划,以确认是否真正使用了索引。

行级锁与死锁

MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。

在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。

当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。

发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。

有多种方法可以避免死锁，这里只介绍常见的三种

1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。

2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；

3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；